package database

import (
	"database/sql"
	"fmt"
	"github.com/google/uuid"
	"time"
)

type MultipleEventsIdError struct {
	Detail string
}

func (e MultipleEventsIdError) Error() string {
	return fmt.Sprintf("multiple events id: %s", e.Detail)
}

// ActiveEvents represents active events with relative properties
type ActiveEvents struct {
	UUID        uuid.UUID `json:"uuid"`
	EventNumber int       `json:"event_number"`
	EventDate   time.Time `json:"event_date"`
	CentralID   string    `json:"central_id"`
	Priority    int       `json:"priority"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	Role        string    `json:"role"`
	Status      string    `json:"status"`
	ModifiedBy  string    `json:"modified_by"`
	Timestamp   time.Time `json:"timestamp"`
}

const (
	TaskNotdone = "notdone"
	TaskWorking = "working"
	TaskDone    = "done"
)

// ActiveEventsRepository represents a repository for managing active events
type ActiveEventsRepository struct {
	db          *sql.DB
	eventNumber int
	centrailId  string
}

// NewActiveEventRepository creates a new instance of ActiveEventsRepository with the provided database connection.
// It returns a pointer to the created ActiveEventsRepository.
func NewActiveEventRepository(db *sql.DB, eventNumber int, centralId string) *ActiveEventsRepository {
	return &ActiveEventsRepository{
		db:          db,
		eventNumber: eventNumber,
		centrailId:  centralId,
	}
}

// Add inserts a new active event record into the database.
// The task parameter represents the active event object to be added.
// The tx parameter is a transaction object that encapsulates the database transaction.
// This method executes a database query to insert the provided active event data into the active_events table.
// It returns an error if the database operation fails.
func (e *ActiveEventsRepository) Add(tx *sql.Tx, task ActiveEvents) error {
	query := `INSERT INTO active_events (UUID, event_number , event_date, central_id, Priority, Title, Description, 
				Role, Status,modified_by, Timestamp)
			   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

	_, err := tx.Exec(query, task.UUID, task.EventNumber, task.EventDate, task.CentralID, task.Priority, task.Title,
		task.Description, task.Role, task.Status, task.ModifiedBy, task.Timestamp)

	return err
}

// TaskToActiveEvent converts a Task object into an ActiveEvents object.
// It creates a new ActiveEvents object with the UUID generated by uuid.New(),
// the eventNumber and centralId properties from the ActiveEventsRepository,
// and the priority, title, description, role, and status properties from the Task object.
// It returns the converted ActiveEvents object.
func (e *ActiveEventsRepository) TaskToActiveEvent(task Task) ActiveEvents {
	return ActiveEvents{
		UUID:        uuid.New(),
		EventNumber: e.eventNumber,
		CentralID:   e.centrailId,
		Priority:    task.Priority,
		Title:       task.Title,
		Description: task.Description,
		Role:        task.Role,
		Status:      TaskNotdone,
	}
}

// CreateFromTaskList takes a list of tasks and creates corresponding active event records in the database.
// The tasks parameter is a slice of Task objects representing the tasks to be converted into active events.
// This method begins a transaction on the database, converts each task into an ActiveEvents object,
// and inserts it into the active_events table using the Add method. If any error occurs during this process,
// the transaction is rolled back and the error is returned. Otherwise, the transaction is committed.
// It returns an error if the transaction fails to begin, any Add operation fails, or the transaction fails to commit.
func (e *ActiveEventsRepository) CreateFromTaskList(tasks []Task) error {

	// Begin transaction
	tx, err := e.db.Begin()
	if err != nil {
		return err
	}

	for _, task := range tasks {
		t := e.TaskToActiveEvent(task)
		err = e.Add(tx, t)
		if err != nil {
			return err
		}
	}

	return tx.Commit()
}

// GetByCentralID retrieves active events from the database based on the provided central ID.
// The db parameter is a reference to the database connection.
// The centralID parameter is the central ID used to filter the events.
// This method executes a database query to select active events from the active_events table
// with the matching central ID.
// It returns a slice of ActiveEvents representing the retrieved events,
// a slice of int representing the unique event numbers found,
// and an error if the database operation fails.
func (e *ActiveEventsRepository) GetByCentralID() ([]ActiveEvents, []int, error) {
	rows, err := e.db.Query(`SELECT uuid, event_number, event_date, central_id, priority, title, 
    description, role, status, modified_by, timestamp FROM active_events WHERE central_id = ?`, e.centrailId)
	if err != nil {
		return nil, nil, err
	}
	defer rows.Close()

	events := []ActiveEvents{}
	eventNumbers := []int{}

	// Scan row to return slice and count unique event numbers
	for rows.Next() {
		var event ActiveEvents
		if err := rows.Scan(event.UUID, event.EventNumber, event.EventDate, event.CentralID, event.Priority, event.Title,
			event.Description, event.Role, event.Status, event.ModifiedBy, event.Timestamp); err != nil {
			return nil, nil, err
		}
		events = append(events, event)

		// Check if event number already exist in slice
		exist := false
		for _, a := range eventNumbers {
			if a == event.EventNumber {
				exist = true
				break
			}
		}

		// add event number if now exist
		if !exist {
			eventNumbers = append(eventNumbers, event.EventNumber)
		}
	}

	// Check if more than one eventNumber is found and return the appropriate error with event list
	if len(eventNumbers) > 1 {
		return nil, eventNumbers, &MultipleEventsIdError{Detail: "Multiple events found for specified centralId"}
	}

	return events, eventNumbers, nil
}

// GetByCentralAndNumber retrieves active events from the database based on the provided central ID and event number.
// This method executes a database query to select active events from the active_events table
// with the matching central ID and event number.
// It returns a slice of ActiveEvents representing the retrieved events
// and an error if the database operation fails.
func (e *ActiveEventsRepository) GetByCentralAndNumber() ([]ActiveEvents, error) {
	rows, err := e.db.Query(`SELECT uuid, event_number, event_date, central_id, priority, title, description, role, status, modified_by, timestamp
								FROM active_events WHERE central_id = ? AND event_number = ?`, e.centrailId, e.eventNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	events := []ActiveEvents{}

	for rows.Next() {
		var event ActiveEvents
		if err := rows.Scan(&event.UUID, &event.EventNumber, &event.EventDate, &event.CentralID, &event.Priority,
			&event.Title, &event.Description, &event.Role, &event.Status, &event.ModifiedBy, &event.Timestamp); err != nil {
			return nil, err
		}
		events = append(events, event)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return events, nil
}

// UpdateStatus updates the status and modified_by fields of an active event record in the database
// with the provided UUID. The status parameter represents the new status value,
// and the modifiedby parameter represents the user who modified the record.
// This method executes a database query to update the active_events table
// with the provided parameters using the UUID as the identifier.
// It returns an error if the database operation fails.
func (e *ActiveEventsRepository) UpdateStatus(uuid uuid.UUID, status string, modifiedby string) error {

	stmt, err := e.db.Prepare("UPDATE active_events SET status = ?, modified_by = ? WHERE uuid = ?")
	if err != nil {
		return err
	}
	defer stmt.Close()

	// execute statement
	_, err = stmt.Exec(status, modifiedby, uuid)
	if err != nil {
		return err
	}

	return nil
}

// DeleteEvent deletes an active event record from the database based on the provided central ID and event number.
// This method executes a database query to delete the active event record from the active_events table
// with the matching central ID and event number.
// It returns an error if the database operation fails.
func (e *ActiveEventsRepository) DeleteEvent() error {
	stmt, err := e.db.Prepare("DELETE FROM active_events where central_id = ? AND event_number = ?")
	if err != nil {
		return err
	}

	_, err = stmt.Exec(e.centrailId, e.eventNumber)
	if err != nil {
		return err
	}

	return nil
}
